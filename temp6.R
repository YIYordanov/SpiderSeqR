
#' 
#' 
#' @param df Data frame with series_id column containing GSEs
#' @return Data frame with appended pubmed_id column
#' 
#' NOTE: currently relies entirely on pubmed_id column in gse table from the database generated by GEOmetadb
#' It appears that only approximately 20% of entries in that column are in agreement with the online version of GEO (the rest has missing pubmed_ids)
#' 
#' @examples
#' findPubmedIDs(df)
#' 
#' @keywords internal
#' 
#' ===*===
#' 
appendGSEColumns <- function(df, gse_columns){
  
  print("Running appendGSEColumns")
  
  database_name <- "geo_con"
  database_env <- ".GlobalEnv"
  
  if (sum(!is.na(df$series_id))==0){
    df$pubmed_id <- NA
    warning("No GSEs to use for searching for pubmed_id")
    print("findPubmedIDs completed")
    return(df)
  }
  
  #Insert clause about no entries ===*===
  
  df_length <- dim(df)[1]
  df$pubmed_id <- NA
  for (i in 1:df_length){
    series <- df$series_id[i]
    series <- unlist(strsplit(series, split = ","))
    p <- NULL
    for (j in seq_along(series)){
      p <- c(p, as.character(DBI::dbGetQuery(get(database_name, envir = get(database_env)), paste0("SELECT pubmed_id FROM gse WHERE gse = '", series[j], "'"))))
    }
    #p <- c("NA", "NA", 8, 9, NA,11)
    p <- unique(p)
    
    p[grepl("^NA$", p)] <- NA #Replace character NAs with real NAs
    
    if (length(p) >1){
      p <- p[!is.na(p)]
    }
    p <- paste(p, collapse = ",")
    df$pubmed_id[i] <- p
  }
  
  #df <- df[,c(1:5, 33, 6:32)]
  
  print("findPubmedIDs completed")
  return(df)
  
  
}


#----------------------------


GSE44563 <- searchForAccession("GSE44563", file_output = FALSE) # single gse

GSM277339 <- searchForAccession("GSM277339", file_output = FALSE) # triple gse
GSM640576 <- searchForAccession("GSM640576", file_output = FALSE) # double gse

df_whole <- rbind(GSE44563, GSM277339, GSM640576)
df <- df_whole[ ,c(2, 5,4, 11)]

gse_columns <- c("gse", "title", "type", "pubmed_id")
#gse_columns <- dbListFields(geo_con, "gse")


#--------

database_name <- "geo_con"
database_env <- ".GlobalEnv"

# ===*=== Clause to interpret "*" as all fields
# ===*=== Check columns in the column list (maybe)
# ===*=== Clause to return original df if no matches/no columns

# Collapse column list to comma separated string for SQLite
gse_columns_sql <- paste0(gse_columns, sep = ", ", collapse = "")
gse_columns_sql <- substr(gse_columns_sql, 1, nchar(gse_columns_sql)-2)


df_ids <- df %>% dplyr::select(sample, series_id)
df_ids_long <- df_ids %>% tidyr::separate_rows(series_id, sep = ",")


gse_list <- unique(df_ids_long$series_id)
#gse_list <- c("GSE25899", "GSE10936", "nth") #what if no results or only some

gse_df <- data.frame()
for (s in seq_along(gse_list)){
  
  query <- paste0("SELECT ", gse_columns_sql, " FROM gse WHERE gse = '", gse_list[s], "'")
  chunk <- DBI::dbGetQuery(get(database_name, envir = get(database_env)), query)
  gse_df <- rbind(gse_df, chunk)
}

colnames(gse_df)[grepl("^gse$", colnames(gse_df))] <- "series_id"


df_ids_long <- df_ids_long %>% dplyr::left_join(gse_df)

collapsible_columns <- colnames(df_ids_long)
collapsible_columns <- collapsible_columns[!grepl("sample", collapsible_columns)]
collapsible_columns <- collapsible_columns[!grepl("series_id", collapsible_columns)]

for (c in seq_along(collapsible_columns)){
#for (c in 1){
  x[c] <- paste0(collapsible_columns[c], " = paste(", collapsible_columns[c], ", collapse = ';;' )" )
}

collapse_expression <- paste0(x, collapse = "", sep = ", ")
collapse_expression <- substr(collapse_expression, 1, nchar(collapse_expression)-2)


collapse_expression <- paste0("df_ids_long %>% dplyr::group_by(sample) %>% dplyr::summarise(", collapse_expression, ")")

df_ids_long <- eval(parse(text = collapse_expression))









