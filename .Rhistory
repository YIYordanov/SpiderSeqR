output_df <- data.frame()
for (g in seq_along(gsm_list)){ #For each GSM
##OPTION 1:
##ASSUMPTION: all fields containing GSM begin with GSM (speeds up performance)
##Need to be careful with the experiment_attribute column - this wouldn't work!
#query <- paste0("SELECT ", sra_columns_sql, " FROM sra WHERE ", queryWriter(gsm_list[g], gsm_columns, sql_before = " LIKE '"))
#OPTION 2:
query <- paste0("SELECT ", sra_columns_sql, " FROM sra WHERE run_alias LIKE '", gsm_list[g], "%' OR experiment_attribute LIKE '%", gsm_list[g], "%'")
current_chunk <- dbGetQuery(sra_con, query)
#print(dim(current_chunk))
#Verify that correct GSMs have been captured
gsm_regexp <- paste0(gsm_list[g], "[^0-9]")
current_chunk <- current_chunk[conditionVerifier2(current_chunk, gsm_regexp, gsm_columns),]
if (dim(current_chunk)[1] != 0){
output_df <- rbind(output_df, current_chunk) #Add current chunk to the output
gsm_count <- gsm_count + 1 #Increase the counter
}
}
print(paste0("Found results for ", gsm_count, " out of ", gsm_total, " GSMs"))
output_df$run_GSM <- NA
output_df$exp_GSM <- NA
output_df$run_GSM <- gsub("(GSM\\d\\d\\d+).*", "\\1", output_df$run_alias, perl=TRUE)
output_df$exp_GSM <- gsub(".+?(GSM\\d\\d\\d+).*", "\\1", output_df$experiment_attribute, perl= TRUE)
output_df$GSM_check <- output_df$run_GSM == output_df$experiment_attribute
return(output_df)
}
p2 <- searchForGSMinSRA(c("GSM2538939", "GSM2539030"))
p2
searchForGSMinSRA <- function(gsm_list, sra_columns=NA){
if (accessionClassifier(gsm_list)!="gsm"){
stop("gsm_list must only contain GSM entries")
}
#Remove duplicates
gsm_list <- unique(gsm_list)
gsm_list <- gsm_list[digitSort(gsm_list)]
#Get the total and count
gsm_total <- length(gsm_list)
gsm_count <- 0
#Set parameters
##OPTION 1 (faster, but misses 5k entries):
##gsm_columns <- c("experiment_title", "run_alias") #Pointless: all GSMs that exist within experiment_title are already contained within run_alias
#gsm_columns <- c("run_alias")
#OPTION 2 (optimal for not missing entries)
gsm_columns <- c("run_alias", "experiment_attribute")
if (is.na(sra_columns)){
sra_columns <- c("study_accession", "sample_accession", "experiment_accession", "run_accession")
}
sra_columns <- append(sra_columns, gsm_columns) #Must include gsm_columns to later verify the match
sra_columns_sql <- paste(sra_columns, collapse = ", ")
#Initialise the output data frame
output_df <- data.frame()
for (g in seq_along(gsm_list)){ #For each GSM
##OPTION 1:
##ASSUMPTION: all fields containing GSM begin with GSM (speeds up performance)
##Need to be careful with the experiment_attribute column - this wouldn't work!
#query <- paste0("SELECT ", sra_columns_sql, " FROM sra WHERE ", queryWriter(gsm_list[g], gsm_columns, sql_before = " LIKE '"))
#OPTION 2:
query <- paste0("SELECT ", sra_columns_sql, " FROM sra WHERE run_alias LIKE '", gsm_list[g], "%' OR experiment_attribute LIKE '%", gsm_list[g], "%'")
current_chunk <- dbGetQuery(sra_con, query)
#print(dim(current_chunk))
#Verify that correct GSMs have been captured
gsm_regexp <- paste0(gsm_list[g], "[^0-9]")
current_chunk <- current_chunk[conditionVerifier2(current_chunk, gsm_regexp, gsm_columns),]
if (dim(current_chunk)[1] != 0){
output_df <- rbind(output_df, current_chunk) #Add current chunk to the output
gsm_count <- gsm_count + 1 #Increase the counter
}
}
print(paste0("Found results for ", gsm_count, " out of ", gsm_total, " GSMs"))
output_df$run_GSM <- NA
output_df$exp_GSM <- NA
output_df$run_GSM <- gsub("(GSM\\d\\d\\d+).*", "\\1", output_df$run_alias, perl=TRUE)
output_df$exp_GSM <- gsub(".+?(GSM\\d\\d\\d+).*", "\\1", output_df$experiment_attribute, perl= TRUE)
output_df$GSM_check <- output_df$run_GSM == output_df$exp_GSM
return(output_df)
}
p2 <- searchForGSMinSRA(c("GSM2538939", "GSM2539030"))
p2
output_df[,c("study_accession", "sample_accession", "experiment_accession")]
output_df[,c("study_accession", "sample_accession", "experiment_accession", "run_accession", "GSM", "GSM_check")]
searchForGSMinSRA <- function(gsm_list, sra_columns=NA){
if (accessionClassifier(gsm_list)!="gsm"){
stop("gsm_list must only contain GSM entries")
}
#Remove duplicates
gsm_list <- unique(gsm_list)
gsm_list <- gsm_list[digitSort(gsm_list)]
#Get the total and count
gsm_total <- length(gsm_list)
gsm_count <- 0
#Set parameters
##OPTION 1 (faster, but misses 5k entries):
##gsm_columns <- c("experiment_title", "run_alias") #Pointless: all GSMs that exist within experiment_title are already contained within run_alias
#gsm_columns <- c("run_alias")
#OPTION 2 (optimal for not missing entries)
gsm_columns <- c("run_alias", "experiment_attribute")
if (is.na(sra_columns)){
sra_columns <- c("study_accession", "sample_accession", "experiment_accession", "run_accession")
}
sra_columns <- append(sra_columns, gsm_columns) #Must include gsm_columns to later verify the match
sra_columns_sql <- paste(sra_columns, collapse = ", ")
#Initialise the output data frame
output_df <- data.frame()
for (g in seq_along(gsm_list)){ #For each GSM
##OPTION 1:
##ASSUMPTION: all fields containing GSM begin with GSM (speeds up performance)
##Need to be careful with the experiment_attribute column - this wouldn't work!
#query <- paste0("SELECT ", sra_columns_sql, " FROM sra WHERE ", queryWriter(gsm_list[g], gsm_columns, sql_before = " LIKE '"))
#OPTION 2:
query <- paste0("SELECT ", sra_columns_sql, " FROM sra WHERE run_alias LIKE '", gsm_list[g], "%' OR experiment_attribute LIKE '%", gsm_list[g], "%'")
current_chunk <- dbGetQuery(sra_con, query)
#print(dim(current_chunk))
#Verify that correct GSMs have been captured
gsm_regexp <- paste0(gsm_list[g], "[^0-9]")
current_chunk <- current_chunk[conditionVerifier2(current_chunk, gsm_regexp, gsm_columns),]
if (dim(current_chunk)[1] != 0){
output_df <- rbind(output_df, current_chunk) #Add current chunk to the output
gsm_count <- gsm_count + 1 #Increase the counter
}
}
print(paste0("Found results for ", gsm_count, " out of ", gsm_total, " GSMs"))
output_df$run_GSM <- NA
output_df$exp_GSM <- NA
output_df$GSM <- gsub("(GSM\\d\\d\\d+).*", "\\1", output_df$run_alias, perl=TRUE) #Named GSM so that exp_GSM can be dropped later
output_df$exp_GSM <- gsub(".+?(GSM\\d\\d\\d+).*", "\\1", output_df$experiment_attribute, perl= TRUE)
output_df$GSM_check <- output_df$GSM == output_df$exp_GSM
output_df <- output_df[,c("study_accession", "sample_accession", "experiment_accession", "run_accession", "GSM", "GSM_check")]
return(output_df)
}
p2 <- searchForGSMinSRA(c("GSM2538939", "GSM2539030"))
p2
as.numeric(p2$GSM_check)
searchForGSMinSRA <- function(gsm_list, sra_columns=NA){
if (accessionClassifier(gsm_list)!="gsm"){
stop("gsm_list must only contain GSM entries")
}
#Remove duplicates
gsm_list <- unique(gsm_list)
gsm_list <- gsm_list[digitSort(gsm_list)]
#Get the total and count
gsm_total <- length(gsm_list)
gsm_count <- 0
#Set parameters
##OPTION 1 (faster, but misses 5k entries):
##gsm_columns <- c("experiment_title", "run_alias") #Pointless: all GSMs that exist within experiment_title are already contained within run_alias
#gsm_columns <- c("run_alias")
#OPTION 2 (optimal for not missing entries)
gsm_columns <- c("run_alias", "experiment_attribute")
if (is.na(sra_columns)){
sra_columns <- c("study_accession", "sample_accession", "experiment_accession", "run_accession")
}
sra_columns <- append(sra_columns, gsm_columns) #Must include gsm_columns to later verify the match
sra_columns_sql <- paste(sra_columns, collapse = ", ")
#Initialise the output data frame
output_df <- data.frame()
for (g in seq_along(gsm_list)){ #For each GSM
##OPTION 1:
##ASSUMPTION: all fields containing GSM begin with GSM (speeds up performance)
##Need to be careful with the experiment_attribute column - this wouldn't work!
#query <- paste0("SELECT ", sra_columns_sql, " FROM sra WHERE ", queryWriter(gsm_list[g], gsm_columns, sql_before = " LIKE '"))
#OPTION 2:
query <- paste0("SELECT ", sra_columns_sql, " FROM sra WHERE run_alias LIKE '", gsm_list[g], "%' OR experiment_attribute LIKE '%", gsm_list[g], "%'")
current_chunk <- dbGetQuery(sra_con, query)
#print(dim(current_chunk))
#Verify that correct GSMs have been captured
gsm_regexp <- paste0(gsm_list[g], "[^0-9]")
current_chunk <- current_chunk[conditionVerifier2(current_chunk, gsm_regexp, gsm_columns),]
if (dim(current_chunk)[1] != 0){
output_df <- rbind(output_df, current_chunk) #Add current chunk to the output
gsm_count <- gsm_count + 1 #Increase the counter
}
}
print(paste0("Found results for ", gsm_count, " out of ", gsm_total, " GSMs"))
output_df$run_GSM <- NA
output_df$exp_GSM <- NA
output_df$GSM <- gsub("(GSM\\d\\d\\d+).*", "\\1", output_df$run_alias, perl=TRUE) #Named GSM so that exp_GSM can be dropped later
output_df$exp_GSM <- gsub(".+?(GSM\\d\\d\\d+).*", "\\1", output_df$experiment_attribute, perl= TRUE)
output_df$GSM_check <- output_df$GSM == output_df$exp_GSM #Check whether run_alias and experiment_accession give consistent results
#Return selected columns
output_df <- output_df[,c("study_accession", "sample_accession", "experiment_accession", "run_accession", "GSM", "GSM_check")]
return(output_df)
}
5 %in% c(1:5)
getAnywhere(accessionClassifier())
dbListFields(geo_con, "gsm")
convertGEO <- function(accession_vector){
geo_class <- accessionClassifier(accession_vector)
if (!(geo_class %in% c("gsm", "series_id"))){
stop("accession_vector must only contain GSE/GSM entries")
}
x <- unique(accession_vector)
x <- x[digitSort(x)]
geo_columns <- c("gsm", "series_id")
search_count <- 0
accession_df <- data.frame()
for (a in seq_along(x)){
query <- paste0("SELECT ", geo_columns, " FROM gsm WHERE ", accession_class, " = '", x[a], "'")
print(query)
chunk <- dbGetQuery(geo_con, query)
search_count <- search_count + as.integer(dim(chunk)[1]>=1)
accession_df <- rbind(accession_df, chunk)
}
print("Found results for ", search_count, " out of ", length(x), " entries")
}
p3 <- convertGEO(c("GSM2538939", "GSM2539030"))
convertGEO <- function(accession_vector){
geo_class <- accessionClassifier(accession_vector)
if (!(geo_class %in% c("gsm", "series_id"))){
stop("accession_vector must only contain GSE/GSM entries")
}
x <- unique(accession_vector)
x <- x[digitSort(x)]
geo_columns <- c("gsm", "series_id")
search_count <- 0
accession_df <- data.frame()
for (a in seq_along(x)){
query <- paste0("SELECT ", geo_columns, " FROM gsm WHERE ", geo_class, " = '", x[a], "'")
print(query)
chunk <- dbGetQuery(geo_con, query)
search_count <- search_count + as.integer(dim(chunk)[1]>=1)
accession_df <- rbind(accession_df, chunk)
}
print("Found results for ", search_count, " out of ", length(x), " entries")
}
p3 <- convertGEO(c("GSM2538939", "GSM2539030"))
convertGEO <- function(accession_vector){
geo_class <- accessionClassifier(accession_vector)
if (!(geo_class %in% c("gsm", "series_id"))){
stop("accession_vector must only contain GSE/GSM entries")
}
x <- unique(accession_vector)
x <- x[digitSort(x)]
geo_columns <- c("gsm", "series_id")
search_count <- 0
accession_df <- data.frame()
for (a in seq_along(x)){
query <- paste0("SELECT ", geo_columns, " FROM gsm WHERE ", geo_class, " = '", x[a], "'")
print(query)
chunk <- dbGetQuery(geo_con, query)
search_count <- search_count + as.integer(dim(chunk)[1]>=1)
accession_df <- rbind(accession_df, chunk)
}
print(paste0("Found results for ", search_count, " out of ", length(x), " entries"))
}
p3 <- convertGEO(c("GSM2538939", "GSM2539030"))
p3
convertGEO <- function(accession_vector){
geo_class <- accessionClassifier(accession_vector)
if (!(geo_class %in% c("gsm", "series_id"))){
stop("accession_vector must only contain GSE/GSM entries")
}
x <- unique(accession_vector)
x <- x[digitSort(x)]
geo_columns <- c("gsm", "series_id")
search_count <- 0
accession_df <- data.frame()
for (a in seq_along(x)){
query <- paste0("SELECT ", geo_columns, " FROM gsm WHERE ", geo_class, " = '", x[a], "'")
print(query)
chunk <- dbGetQuery(geo_con, query)
search_count <- search_count + as.integer(dim(chunk)[1]>=1)
accession_df <- rbind(accession_df, chunk)
}
print(paste0("Found results for ", search_count, " out of ", length(x), " entries"))
return(accession_df)
}
p3 <- convertGEO(c("GSM2538939", "GSM2539030"))
p3
convertGEO <- function(accession_vector){
geo_class <- accessionClassifier(accession_vector)
if (!(geo_class %in% c("gsm", "series_id"))){
stop("accession_vector must only contain GSE/GSM entries")
}
x <- unique(accession_vector)
x <- x[digitSort(x)]
geo_columns <- c("gsm", "series_id")
geo_columns <- paste0(geo_columns, collapse = ", ")
search_count <- 0
accession_df <- data.frame()
for (a in seq_along(x)){
query <- paste0("SELECT ", geo_columns, " FROM gsm WHERE ", geo_class, " = '", x[a], "'")
print(query)
chunk <- dbGetQuery(geo_con, query)
search_count <- search_count + as.integer(dim(chunk)[1]>=1)
accession_df <- rbind(accession_df, chunk)
}
print(paste0("Found results for ", search_count, " out of ", length(x), " entries"))
return(accession_df)
}
p3 <- convertGEO(c("GSM2538939", "GSM2539030"))
p3
p4 <- searchForGSMinSRA(p3$gsm)
merge(p3, p4)
searchForGSMinSRA <- function(gsm_list, sra_columns=NA){
if (accessionClassifier(gsm_list)!="gsm"){
stop("gsm_list must only contain GSM entries")
}
#Remove duplicates
gsm_list <- unique(gsm_list)
gsm_list <- gsm_list[digitSort(gsm_list)]
#Get the total and count
gsm_total <- length(gsm_list)
gsm_count <- 0
#Set parameters
##OPTION 1 (faster, but misses 5k entries):
##gsm_columns <- c("experiment_title", "run_alias") #Pointless: all GSMs that exist within experiment_title are already contained within run_alias
#gsm_columns <- c("run_alias")
#OPTION 2 (optimal for not missing entries)
gsm_columns <- c("run_alias", "experiment_attribute")
if (is.na(sra_columns)){
sra_columns <- c("study_accession", "sample_accession", "experiment_accession", "run_accession")
}
sra_columns <- append(sra_columns, gsm_columns) #Must include gsm_columns to later verify the match
sra_columns_sql <- paste(sra_columns, collapse = ", ")
#Initialise the output data frame
output_df <- data.frame()
for (g in seq_along(gsm_list)){ #For each GSM
##OPTION 1:
##ASSUMPTION: all fields containing GSM begin with GSM (speeds up performance)
##Need to be careful with the experiment_attribute column - this wouldn't work!
#query <- paste0("SELECT ", sra_columns_sql, " FROM sra WHERE ", queryWriter(gsm_list[g], gsm_columns, sql_before = " LIKE '"))
#OPTION 2:
query <- paste0("SELECT ", sra_columns_sql, " FROM sra WHERE run_alias LIKE '", gsm_list[g], "%' OR experiment_attribute LIKE '%", gsm_list[g], "%'")
current_chunk <- dbGetQuery(sra_con, query)
#print(dim(current_chunk))
#Verify that correct GSMs have been captured
gsm_regexp <- paste0(gsm_list[g], "[^0-9]")
current_chunk <- current_chunk[conditionVerifier2(current_chunk, gsm_regexp, gsm_columns),]
if (dim(current_chunk)[1] != 0){
output_df <- rbind(output_df, current_chunk) #Add current chunk to the output
gsm_count <- gsm_count + 1 #Increase the counter
}
}
print(paste0("Found results for ", gsm_count, " out of ", gsm_total, " GSMs"))
output_df$run_gsm <- NA
output_df$exp_gsm <- NA
output_df$gsm <- gsub("(GSM\\d\\d\\d+).*", "\\1", output_df$run_alias, perl=TRUE) #Named GSM so that exp_gsm can be dropped later
output_df$exp_gsm <- gsub(".+?(GSM\\d\\d\\d+).*", "\\1", output_df$experiment_attribute, perl= TRUE)
output_df$gsm_check <- output_df$gsm == output_df$exp_gsm #Check whether run_alias and experiment_accession give consistent results
#Return selected columns
output_df <- output_df[,c("study_accession", "sample_accession", "experiment_accession", "run_accession", "gsm", "gsm_check")]
return(output_df)
}
merge(p3, p4)
p3 <- convertGEO(c("GSM2538939", "GSM2539030"))
p4 <- searchForGSMinSRA(p3$gsm)
merge(p3, p4)
p3
p3[3,] <- c("sth", "nth"
)
p3
merge(p3, p4)
?merge
merge(p3, p4, all.x = TRUE)
convertGEO <- function(accession_vector){
geo_class <- accessionClassifier(accession_vector)
if (!(geo_class %in% c("gsm", "series_id"))){
stop("accession_vector must only contain GSE/GSM entries")
}
x <- unique(accession_vector)
x <- x[digitSort(x)]
geo_columns <- c("gsm", "series_id")
geo_columns <- paste0(geo_columns, collapse = ", ")
search_count <- 0
geo_df <- data.frame()
for (a in seq_along(x)){
query <- paste0("SELECT ", geo_columns, " FROM gsm WHERE ", geo_class, " = '", x[a], "'")
print(query)
chunk <- dbGetQuery(geo_con, query)
search_count <- search_count + as.integer(dim(chunk)[1]>=1)
geo_df <- rbind(geo_df, chunk)
}
print(paste0("Found results for ", search_count, " out of ", length(x), " GEO entries"))
sra_df <- searchForGSMinSRA(geo_df$gsm)
output_df <- merge(geo_df, sra_df, all.x = TRUE)
return(output_df)
}
t <- convertGEO(c("GSM2538939", "GSM2539030"))
t
searchForGSMinSRA <- function(gsm_list, sra_columns=NA){
if (accessionClassifier(gsm_list)!="gsm"){
stop("gsm_list must only contain GSM entries")
}
#Remove duplicates
gsm_list <- unique(gsm_list)
gsm_list <- gsm_list[digitSort(gsm_list)]
#Get the total and count
gsm_total <- length(gsm_list)
gsm_count <- 0
#Set parameters
##OPTION 1 (faster, but misses 5k entries):
##gsm_columns <- c("experiment_title", "run_alias") #Pointless: all GSMs that exist within experiment_title are already contained within run_alias
#gsm_columns <- c("run_alias")
#OPTION 2 (optimal for not missing entries)
gsm_columns <- c("run_alias", "experiment_attribute")
if (is.na(sra_columns)){
sra_columns <- c("study_accession", "sample_accession", "experiment_accession", "run_accession")
}
sra_columns <- append(sra_columns, gsm_columns) #Must include gsm_columns to later verify the match
sra_columns_sql <- paste(sra_columns, collapse = ", ")
#Initialise the output data frame
output_df <- data.frame()
for (g in seq_along(gsm_list)){ #For each GSM
##OPTION 1:
##ASSUMPTION: all fields containing GSM begin with GSM (speeds up performance)
##Need to be careful with the experiment_attribute column - this wouldn't work!
#query <- paste0("SELECT ", sra_columns_sql, " FROM sra WHERE ", queryWriter(gsm_list[g], gsm_columns, sql_before = " LIKE '"))
#OPTION 2:
query <- paste0("SELECT ", sra_columns_sql, " FROM sra WHERE run_alias LIKE '", gsm_list[g], "%' OR experiment_attribute LIKE '%", gsm_list[g], "%'")
current_chunk <- dbGetQuery(sra_con, query)
#print(dim(current_chunk))
#Verify that correct GSMs have been captured
gsm_regexp <- paste0(gsm_list[g], "[^0-9]")
current_chunk <- current_chunk[conditionVerifier2(current_chunk, gsm_regexp, gsm_columns),]
if (dim(current_chunk)[1] != 0){
output_df <- rbind(output_df, current_chunk) #Add current chunk to the output
gsm_count <- gsm_count + 1 #Increase the counter
}
}
print(paste0("Found results for ", gsm_count, " out of ", gsm_total, " GSMs in SRA"))
output_df$run_gsm <- NA
output_df$exp_gsm <- NA
output_df$gsm <- gsub("(GSM\\d\\d\\d+).*", "\\1", output_df$run_alias, perl=TRUE) #Named GSM so that exp_gsm can be dropped later
output_df$exp_gsm <- gsub(".+?(GSM\\d\\d\\d+).*", "\\1", output_df$experiment_attribute, perl= TRUE)
output_df$gsm_check <- output_df$gsm == output_df$exp_gsm #Check whether run_alias and experiment_accession give consistent results
#Return selected columns
output_df <- output_df[,c("run_accession", "experiment_accession", "sample_accession", "study_accession", "gsm", "gsm_check")]
return(output_df)
}
convertGEO <- function(accession_vector){
geo_class <- accessionClassifier(accession_vector)
if (!(geo_class %in% c("gsm", "series_id"))){
stop("accession_vector must only contain GSE/GSM entries")
}
x <- unique(accession_vector)
x <- x[digitSort(x)]
geo_columns <- c("gsm", "series_id")
geo_columns <- paste0(geo_columns, collapse = ", ")
search_count <- 0
geo_df <- data.frame()
for (a in seq_along(x)){
query <- paste0("SELECT ", geo_columns, " FROM gsm WHERE ", geo_class, " = '", x[a], "'")
print(query)
chunk <- dbGetQuery(geo_con, query)
search_count <- search_count + as.integer(dim(chunk)[1]>=1)
geo_df <- rbind(geo_df, chunk)
}
print(paste0("Found results for ", search_count, " out of ", length(x), " GEO entries"))
sra_df <- searchForGSMinSRA(geo_df$gsm)
output_df <- merge(geo_df, sra_df, all.x = TRUE)
return(output_df)
}
t <- convertGEO(c("GSM2538939", "GSM2539030"))
t
devtools::load_all()
.GlobalEnv$sra_con <- dbConnect(SQLite(), dbname = 'SRAmetadb.sqlite')
.GlobalEnv$geo_con <- dbConnect(SQLite(),'GEOmetadb.sqlite')
dbGetQuery(sra_con, "SELECT study_accession FROM sra WHERE experiment_title LIKE '%GSM%' GROUP BY RANDOM() LIMIT 5 ")
convertGEO("GSE82187")
system.time(convertGEO("SRP033220"))
system.time(convertGEO("GSE52594"))
system.time(t <- convertGEO("GSE52594"))
t
profvis(t <- convertGEO(c("GSM2538939", "GSM2539030")))
install.packages("profvis")
library(profvis)
profvis(t <- convertGEO(c("GSM2538939", "GSM2539030")))
View(t)
dbGetQuery(sra_con, "SELECT count(*) FROM sra WHERE run_alias NOT LIKE '%GSM%' AND experiment_attribute LIKE '%GSM%'")
gsm_list <- t$
gsm
str(gsm_list)
profvis::profvis({#Remove duplicates
gsm_list <- unique(gsm_list)
gsm_list <- gsm_list[digitSort(gsm_list)]
#Get the total and count
gsm_total <- length(gsm_list)
gsm_count <- 0
#Set parameters
##OPTION 1 (faster, but misses 5k entries):
##gsm_columns <- c("experiment_title", "run_alias") #Pointless: all GSMs that exist within experiment_title are already contained within run_alias
#gsm_columns <- c("run_alias")
#OPTION 2 (optimal for not missing entries)
gsm_columns <- c("run_alias", "experiment_attribute")
if (is.na(sra_columns)){
sra_columns <- c("study_accession", "sample_accession", "experiment_accession", "run_accession")
}
sra_columns <- append(sra_columns, gsm_columns) #Must include gsm_columns to later verify the match
sra_columns_sql <- paste(sra_columns, collapse = ", ")
#Initialise the output data frame
output_df <- data.frame()
for (g in seq_along(gsm_list)){ #For each GSM
##OPTION 1:
##ASSUMPTION: all fields containing GSM begin with GSM (speeds up performance)
##Need to be careful with the experiment_attribute column - this wouldn't work!
#query <- paste0("SELECT ", sra_columns_sql, " FROM sra WHERE ", queryWriter(gsm_list[g], gsm_columns, sql_before = " LIKE '"))
#OPTION 2:
query <- paste0("SELECT ", sra_columns_sql, " FROM sra WHERE run_alias LIKE '", gsm_list[g], "%' OR experiment_attribute LIKE '%", gsm_list[g], "%'")
current_chunk <- dbGetQuery(sra_con, query)
#print(dim(current_chunk))
#Verify that correct GSMs have been captured
gsm_regexp <- paste0(gsm_list[g], "[^0-9]")
current_chunk <- current_chunk[conditionVerifier2(current_chunk, gsm_regexp, gsm_columns),]
if (dim(current_chunk)[1] != 0){
output_df <- rbind(output_df, current_chunk) #Add current chunk to the output
gsm_count <- gsm_count + 1 #Increase the counter
}
}
print(paste0("Found results for ", gsm_count, " out of ", gsm_total, " GSMs in SRA"))})
dbGetQuery
dbGetQuery(sra_con, "SELECT count(*) FROM sra WHERE experiment_attribute LIKE '%GEO Accession: GSM%'")
dbGetQuery(sra_con, "SELECT count(*) FROM sra WHERE experiment_attribute LIKE '%GSM%'")
